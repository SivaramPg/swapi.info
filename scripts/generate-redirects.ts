/**
 * Generates Netlify _redirects file for ID → slug URL redirects
 * This ensures backward compatibility while having canonical slug URLs
 */

import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs"
import { resolve } from "node:path"

const CATEGORIES = [
	"films",
	"people",
	"planets",
	"species",
	"starships",
	"vehicles",
] as const

interface Entity {
	name?: string
	title?: string
	url: string
}

/**
 * Converts a name to a URL-friendly slug
 */
function slugify(text: string): string {
	return text
		.toLowerCase()
		.trim()
		.replace(/[àáâãäå]/g, "a")
		.replace(/[èéêë]/g, "e")
		.replace(/[ìíîï]/g, "i")
		.replace(/[òóôõö]/g, "o")
		.replace(/[ùúûü]/g, "u")
		.replace(/[ñ]/g, "n")
		.replace(/[ç]/g, "c")
		.replace(/[''"]/g, "")
		.replace(/[^\w\s-]/g, "")
		.replace(/\s+/g, "-")
		.replace(/-+/g, "-")
		.replace(/^-+|-+$/g, "")
}

/**
 * Extracts the numeric ID from a SWAPI URL
 */
function extractIdFromUrl(url: string): string {
	const parts = url.split("/")
	return parts[parts.length - 1].replace(".json", "")
}

/**
 * Gets the display name from an entity
 */
function getEntityName(entity: Entity): string {
	return entity.name ?? entity.title ?? "unknown"
}

function main() {
	const redirects: string[] = []

	// Header comment
	redirects.push("# Auto-generated redirects for ID → slug URLs")
	redirects.push("# Generated by scripts/generate-redirects.ts")
	redirects.push("")

	for (const category of CATEGORIES) {
		const filePath = resolve(process.cwd(), `public/api/${category}/all.json`)

		if (!existsSync(filePath)) {
			console.warn(`Warning: ${filePath} not found, skipping ${category}`)
			continue
		}

		const data: Entity[] = JSON.parse(readFileSync(filePath, "utf-8"))

		// Track slugs to handle collisions
		const usedSlugs = new Set<string>()

		for (const entity of data) {
			const id = extractIdFromUrl(entity.url)
			const name = getEntityName(entity)
			let slug = slugify(name)

			// Handle slug collisions by appending ID
			if (usedSlugs.has(slug)) {
				slug = `${slug}-${id}`
			}
			usedSlugs.add(slug)

			// Only add redirect if ID !== slug (avoid self-redirects)
			if (id !== slug) {
				// 301 permanent redirect from ID to slug
				redirects.push(`/${category}/${id}  /${category}/${slug}  301`)
			}
		}

		redirects.push("")
	}

	// Write to out/_redirects (for post-build) and public/_redirects (as backup)
	const outDir = resolve(process.cwd(), "out")
	const publicDir = resolve(process.cwd(), "public")

	// Create out directory if it doesn't exist (for standalone script runs)
	if (!existsSync(outDir)) {
		mkdirSync(outDir, { recursive: true })
	}

	const redirectContent = redirects.join("\n")

	writeFileSync(resolve(outDir, "_redirects"), redirectContent)
	console.log(`✓ Generated ${outDir}/_redirects`)

	// Also write to public for reference
	writeFileSync(resolve(publicDir, "_redirects"), redirectContent)
	console.log(`✓ Generated ${publicDir}/_redirects`)

	// Count redirects
	const redirectCount = redirects.filter((line) => line.includes("301")).length
	console.log(`✓ Total redirects: ${redirectCount}`)
}

main()
